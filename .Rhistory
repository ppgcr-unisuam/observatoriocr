V(G2)[[i]]$color <- colrs[match(membros.raw$`Categoria do Membro do Projeto`[categ.id], categ)]
}
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color="lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1, vertex.label = V(G2)$media)
V(G2)$cat
V(G2)$color
match(membros.raw$`Categoria do Membro do Projeto`[categ.id], categ
)
categ
# set category
for (i in 1:length(V(G2))){
categ.id <- match(V(G2)[[i]]$name, membros.raw$`Nome do Membro do Projeto`)
V(G2)[[i]]$cat<- membros.raw$`Categoria do Membro do Projeto`[categ.id]
V(G2)[[i]]$color <- colrs[match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ))]
}
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color="lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1, vertex.label = V(G2)$cat)
match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ))
categ.id
membros.raw$`Categoria do Membro do Projeto`[categ.id]
colrs
options(knitr.kable.NA = '--', knitr.table.format = "html")
# read packages
library(knitr)
library(kableExtra)
library(readxl)
library(igraph)
library(RColorBrewer)
# read data and row-bind all Sucupira XLSX files
sheet <- "Projetos - Membros"
membros.raw <- c()
files.to.read <- list.files("../PPGCR Unisuam/Sucupira/", pattern = "xlsx", full.names = TRUE)
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- membros == membros.proj[n]
col.i <- membros == membros.proj[m]
adj.matrix[row.i, col.i] <- 1
}
}
}
# build the graph object
network <- graph_from_adjacency_matrix(adj.matrix, mode = "undirected", weighted = NULL, diag = FALSE)
# plot it
par(oma=c(0, 0, 0, 0), mar = c(0, 0, 0, 0), bg = '#2C3E50', col.lab = "white")
# plot(network, layout = layout.fruchterman.reingold, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color = "lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
# remove isolated nodes
Isolated <- which(degree(network) == 0)
G2 <- delete.vertices(network, Isolated)
LO <- layout_with_fr(network)
LO2 <- LO[-Isolated, ]
colrs <- brewer.pal(n = length(unique(categ)), name = "Set3")
# set category
for (i in 1:length(V(G2))){
categ.id <- match(V(G2)[[i]]$name, membros.raw$`Nome do Membro do Projeto`)
V(G2)[[i]]$cat<- membros.raw$`Categoria do Membro do Projeto`[categ.id]
V(G2)[[i]]$color <- colrs[match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ))]
print(match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ)))
}
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color="lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
G2
G2$name
G2$names
V(G2)#name
V(G2)#categ
V(G2)#categ
V(G2)#nome
V(G2)$nome
V(G2)$name
V(G2)$categ
V(G2)$cat
# set category
for (i in 1:length(V(G2))){
categ.id <- match(V(G2)[[i]]$name, membros.raw$`Nome do Membro do Projeto`)
V(G2)[[i]]$cat<- membros.raw$`Categoria do Membro do Projeto`[categ.id]
V(G2)[i]$color <- colrs[match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ))]
print(match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ)))
}
# set category
for (i in 1:length(V(G2))){
categ.id <- match(V(G2)[[i]]$name, membros.raw$`Nome do Membro do Projeto`)
V(G2)[[i]]$cat<- membros.raw$`Categoria do Membro do Projeto`[categ.id]
V(G2)[i]$color <- colrs[match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ))]
print(match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ)))
}
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color="lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
options(knitr.kable.NA = '--', knitr.table.format = "html")
# read packages
library(knitr)
library(kableExtra)
library(readxl)
library(igraph)
library(RColorBrewer)
# read data and row-bind all Sucupira XLSX files
sheet <- "Projetos - Membros"
membros.raw <- c()
files.to.read <- list.files("../PPGCR Unisuam/Sucupira/", pattern = "xlsx", full.names = TRUE)
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- membros == membros.proj[n]
col.i <- membros == membros.proj[m]
adj.matrix[row.i, col.i] <- 1
}
}
}
# build the graph object
network <- graph_from_adjacency_matrix(adj.matrix, mode = "undirected", weighted = NULL, diag = FALSE)
# plot it
par(oma=c(0, 0, 0, 0), mar = c(0, 0, 0, 0), bg = '#2C3E50', col.lab = "white")
# plot(network, layout = layout.fruchterman.reingold, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color = "lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
# remove isolated nodes
Isolated <- which(degree(network) == 0)
G2 <- delete.vertices(network, Isolated)
LO <- layout_with_fr(network)
LO2 <- LO[-Isolated, ]
colrs <- brewer.pal(n = length(unique(categ)), name = "Set3")
# set category
for (i in 1:length(V(G2))){
categ.id <- match(V(G2)[[i]]$name, membros.raw$`Nome do Membro do Projeto`)
V(G2)[i]$cat<- membros.raw$`Categoria do Membro do Projeto`[categ.id]
V(G2)[i]$color <- colrs[match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ))]
print(match(membros.raw$`Categoria do Membro do Projeto`[categ.id], levels(categ)))
}
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, vertex.color="lightblue", edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
V(G2)
V(G2)$name
V(G2)$cat
V(G2)$color
V(G2)
cols
colrs
plot(colrs)
legend(colrs)
View(colrs)
colrs <- brewer.pal(n = length(unique(categ)), name = "Set3")
colrs
# set category
for (i in 1:length(V(G2))){
categ.id <- match(V(G2)[[i]]$name, membros.raw$`Nome do Membro do Projeto`)
V(G2)[[i]]$categ <- membros.raw$`Categoria do Membro do Projeto`[categ.id]
col.id <- match(V(G2)[[i]]$categ, levels(categ))
V(G2)[i]$color <- colrs[col.id]
}
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 4, edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .2)
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
legend("bottom", legend = levels(categ), col = colrs, hor - TRUE)
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
legend("bottom", legend = levels(categ), col = colrs, hor - TRUE)
legend("bottom", legend = levels(categ), col = colrs, hor = TRUE)
plot(G2, layout = LO2, directed = FALSE, vertex.label = NA, vertex.size = 3, edge.arrow.size = 0, edge.size = 1, edge.color = "white", edge.curved = .1)
legend("bottom", legend = levels(categ), col = colrs, hor = TRUE)
options(knitr.kable.NA = '--', knitr.table.format = "html")
# read packages
library(knitr)
library(kableExtra)
library(readxl)
library(igraph)
library(RColorBrewer)
# read data and row-bind all Sucupira XLSX files
sheet <- "Projetos - Membros"
membros.raw <- c()
files.to.read <- list.files("../PPGCR Unisuam/Sucupira/", pattern = "xlsx", full.names = TRUE)
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
membros
dim(adj.matrix)
n.proj
proj.id
`Nome do Membro do Projeto`[proj.id == proj.id[1]]
membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[1]]
unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[1]])
proj.id[1]
length(membros.proj)
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
membros.proj
i <= 1
i <- 1
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
membros.proj
length(membros.proj)
match(membros, membros.proj[n])
match(membros.proj[n], membros)
n <- 1
match(membros, membros.proj[n])
match(membros.proj[n], membros)
match(membros.proj[n], membros)
m <- 1
match(membros.proj[m], membros)
m <- 2
match(membros.proj[m], membros)
View(adj.matrix)
# read packages
library(knitr)
library(kableExtra)
library(readxl)
library(igraph)
library(RColorBrewer)
# read data and row-bind all Sucupira XLSX files
sheet <- "Projetos - Membros"
membros.raw <- c()
files.to.read <- list.files("../PPGCR Unisuam/Sucupira/", pattern = "xlsx", full.names = TRUE)
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
View(adj.matrix)
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
print(c(row.i, col.i))
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
ifelse(!anyc(row.i, col.i), print(c(row.i, col.i)))
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
ifelse(!any(row.i, col.i), print(c(row.i, col.i)))
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
ifelse(!any(row.i, col.i), print(c(row.i, col.i)), "")
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
print(c(membros.proj[row.i], membros.proj[col.i]))
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
print(c(membros[row.i], membros[col.i]))
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.i <- match(membros.proj[n], membros)
col.i <- match(membros.proj[m], membros)
print(paste(membros[row.i], "- >", membros[col.i]))
adj.matrix[row.i, col.i] <- adj.matrix[row.i, col.i] + 1
}
}
}
E(G2)
E(G2)[[1]]
E(G2)[1]
E(G2)[1][1]
E(G2)[1][[1]]
E(G2)[1][[1]][1]
E(G2)[[1]][[1]][[1]]
E(G2)[[1]]
E(G2)[[1]]$tail
E(G2)[1]$tail
E(G2)[[1]][[1$tail
E(G2)[[1]][[1]]$tail
E(G2)[[1]][1]$tail
E(G2)[[1]][1][1$tail
E(G2)[[1]][1]]$tail
E(G2)[[1]][1]]
E(G2)[[1]]1]
E(G2)[1][1]
E(G2)[[1]][1]
E(G2)[[1]][[1]]
E(G2)[[1]][[1]]$tail
E(G2)[[1]][[1]][1$tail
E(G2)[[1]][[1]][1]$tail
E(G2)[[1]][[1]][[1]]$tail
E(G2)$tail
unlist(E(G2))
unlist(E(G2))[1]
help(layout_in_circle)
options(knitr.kable.NA = '--', knitr.table.format = "html")
# read packages
library(knitr)
library(kableExtra)
library(readxl)
library(igraph)
library(RColorBrewer)
# read data and row-bind all Sucupira XLSX files
sheet <- "Projetos - Membros"
membros.raw <- c()
files.to.read <- list.files("../PPGCR Unisuam/Sucupira/", pattern = "xlsx", full.names = TRUE)
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
for(i in 1:length(files.to.read)){
membros.raw <- rbind(membros.raw, read_excel(files.to.read[i], sheet = sheet))
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.n <- match(membros.proj[n], membros)
col.m <- match(membros.proj[m], membros)
#      print(paste(membros[row.n], "- >", membros[col.m]))
adj.matrix[row.n, col.m] <- adj.matrix[row.n, col.m] + 1
adj.matrix[col.m, row.n] <- adj.matrix[row.n, col.m]
}
}
}
View(adj.matrix)
membros
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.n <- match(membros.proj[n], membros)
col.m <- match(membros.proj[m], membros)
print(paste(membros[row.n], "- >", membros[col.m]))
adj.matrix[row.n, col.m] <- adj.matrix[row.n, col.m] + 1
adj.matrix[col.m, row.n] <- adj.matrix[row.n, col.m]
}
}
}
# create adjacency matrix
proj.id <- as.factor(membros.raw$`Identificador do Projeto de Pesquisa`)
n.proj <- nlevels(proj.id)
membros <- sort(unique(membros.raw$`Nome do Membro do Projeto`))
n.membros <- length(membros)
categ <- as.factor(membros.raw$`Categoria do Membro do Projeto`)
adj.matrix <- matrix(0, nrow = n.membros, ncol = n.membros)
colnames(adj.matrix) <- membros
rownames(adj.matrix) <- membros
# loop across all projects to populate the adjacency matrix
for(i in 1:n.proj){
print(i)
# get the project members
membros.proj <- unique(membros.raw$`Nome do Membro do Projeto`[proj.id == proj.id[i]])
# add a vote to the adjacency matrix
for(n in 1:length(membros.proj)){
for(m in 1:length(membros.proj)){
row.n <- match(membros.proj[n], membros)
col.m <- match(membros.proj[m], membros)
print(paste(membros[row.n], "- >", membros[col.m]))
adj.matrix[row.n, col.m] <- adj.matrix[row.n, col.m] + 1
adj.matrix[col.m, row.n] <- adj.matrix[row.n, col.m]
}
}
}
image(adj.matrix)
